/*
Copyright (c) 2015 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package org.ovirt.api.metamodel.tool;

import static java.util.stream.Collectors.joining;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.HEAD;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Response;

import org.ovirt.api.metamodel.concepts.ListType;
import org.ovirt.api.metamodel.concepts.Locator;
import org.ovirt.api.metamodel.concepts.Method;
import org.ovirt.api.metamodel.concepts.Model;
import org.ovirt.api.metamodel.concepts.Name;
import org.ovirt.api.metamodel.concepts.NameParser;
import org.ovirt.api.metamodel.concepts.Parameter;
import org.ovirt.api.metamodel.concepts.Service;
import org.ovirt.api.metamodel.concepts.StructType;
import org.ovirt.api.metamodel.concepts.Type;

/**
 * This class takes a model and generates the corresponding JAX-RS resource interfaces.
 */
@ApplicationScoped
public class JaxrsGenerator extends JavaGenerator {
    // The content types supported by all the resources, and thus added to the @Produces and @Consumes annotations:
    private static final String[] MEDIA_TYPES = {
        "ApiMediaType.APPLICATION_XML",
        "ApiMediaType.APPLICATION_JSON",
    };

    // The names of the methods that have an special treatment:
    private static final Name ADD = NameParser.parseUsingCase("Add");
    private static final Name GET = NameParser.parseUsingCase("Get");
    private static final Name LIST = NameParser.parseUsingCase("List");
    private static final Name REMOVE = NameParser.parseUsingCase("Remove");
    private static final Name UPDATE = NameParser.parseUsingCase("Update");

    // List of JAX-RS interfaces that support asynchronous creation:
    private static final Set<Name> ASYNCHRONOUS = new HashSet<>();

    private static void addAsyncronous(String name) {
        ASYNCHRONOUS.add(NameParser.parseUsingCase(name));
    }

    static {
        addAsyncronous("Disk");
        addAsyncronous("InstanceType");
        addAsyncronous("InstanceTypeNic");
        addAsyncronous("InstanceTypeWatchdog");
        addAsyncronous("Snapshot");
        addAsyncronous("StorageDomainContentDisk");
        addAsyncronous("Template");
        addAsyncronous("TemplateCdrom");
        addAsyncronous("TemplateDisk");
        addAsyncronous("TemplateNic");
        addAsyncronous("TemplateWatchdog");
        addAsyncronous("Vm");
        addAsyncronous("VmCdrom");
        addAsyncronous("VmDisk");
        addAsyncronous("VmNic");
        addAsyncronous("VmPool");
        addAsyncronous("VmWatchdog");
    }

    // Reference to the object that calculates names for XML schema types and for Java classes generated by the JAXB
    // compiler from the XML schema:
    @Inject private SchemaNames schemaNames;

    // Reference to the object that implements the rules to generate names for Java concepts:
    @Inject private JavaPackages javaPackages;
    @Inject private JavaNames javaNames;
    @Inject private JaxrsNames jaxrsNames;

    public void generate(Model model) {
        model.getServices().forEach(this::generateInterface);
    }

    private void addMethod(String returnType, String methodNameWithArgs, Object ... args) {
        javaBuffer.addLine("default %s %s {", returnType, String.format(methodNameWithArgs, args));
        javaBuffer.addLine(  "throw new UnsupportedOperationException();");
        javaBuffer.addLine("}");
    }

    private void addResponseReturnMethod(String methodNameWithArgs, Object ... args) {
        addMethod("Response", methodNameWithArgs, args);
    }

    private void generateInterface(Service service) {
        // Get the Java name of the inteface:
        JavaClassName interfaceName = jaxrsNames.getInterfaceName(service);

        // Prepare the buffer:
        javaBuffer = new JavaClassBuffer();
        javaBuffer.setClassName(interfaceName);
        generateInterfaceSource(service, interfaceName);
        try {
            javaBuffer.write(outDir);
        }
        catch (IOException exception) {
            exception.printStackTrace();
        }
    }

    private void generateInterfaceSource(Service service, JavaClassName interfaceName) {
        // Get the name of the service:
        Name name = service.getName();

        // Generate the imports:
        javaBuffer.addImport(Produces.class);
        javaBuffer.addImport(javaPackages.getJaxrsPackageName(), "ApiMediaType");

        // Calculate the "extends" clause of the interface declaration:
        List<String> extendsList = new ArrayList<>();
        Service base = service.getBase();
        if (base != null) {
            JavaClassName baseInterfaceName = jaxrsNames.getInterfaceName(base);
            javaBuffer.addImport(baseInterfaceName);
            extendsList.add(baseInterfaceName.getSimpleName());
        }
        if (ASYNCHRONOUS.contains(name)) {
            javaBuffer.addImport(javaPackages.getJaxrsPackageName(), "AsynchronouslyCreatedResource");
            extendsList.add("AsynchronouslyCreatedResource");
        }
        String extendsClause = extendsList.isEmpty()? "": "extends " + String.join(", ", extendsList);

        // Check if this is the root of the tree of services:
        boolean isRoot = service == service.getModel().getRoot();

        // Generate the interface declaration:
        generateDoc(service);
        if (isRoot) {
            javaBuffer.addImport(Path.class);
            javaBuffer.addLine("@Path(\"/\")");
        }
        javaBuffer.addLine("@Produces({ %s })", generateMediaTypes());
        javaBuffer.addLine(
            "public interface %s %s {",
            interfaceName.getSimpleName(),
            extendsClause
        );

        // The root service needs this additional that can't be represented in the model:
        if (isRoot) {
            javaBuffer.addImport(HEAD.class);
            javaBuffer.addImport(Response.class);
            javaBuffer.addLine("@HEAD");
            javaBuffer.addLine("Response head();");
            javaBuffer.addLine();
        }

        // Generate the methods:
        List<Method> methods = service.getDeclaredMethods();
        methods.forEach(x -> generateMethod(x));

        // Generate the resource locators:
        List<Locator> locators = service.getDeclaredLocators();
        locators.forEach(x -> generateLocator(x));

        // Find all the action methods and generate the action resource locator:
        List<Method> actions = new ArrayList<>();
        for (Method method : service.getMethods()) {
            Name methodName = method.getName();
            boolean isAction =
                !ADD.equals(methodName) &&
                !GET.equals(methodName) &&
                !LIST.equals(methodName) &&
                !REMOVE.equals(methodName) &&
                !UPDATE.equals(methodName);
            if (isAction) {
                actions.add(method);
            }
        }
        if (!actions.isEmpty()) {
            generateActionLocator(actions);
        }

        javaBuffer.addLine("}");
    }

    private void generateActionLocator(List<Method> actions) {
        // Generate the imports:
        javaBuffer.addImport(Path.class);
        javaBuffer.addImport(PathParam.class);
        javaBuffer.addImport(javaPackages.getJaxrsPackageName(), "ActionResource");

        // Generate the method:
        javaBuffer.addLine(
            "@Path(\"{action: (%s)}/{oid}\")",
            actions.stream().map(Method::getName).map(jaxrsNames::getActionPath).sorted().collect(joining("|"))
        );
        javaBuffer.addLine(
            "ActionResource getActionResource(@PathParam(\"action\") String action, @PathParam(\"oid\") String oid);"
        );

        javaBuffer.addLine();
    }

    private void generateMethod(Method method) {
        Name name = method.getName();
        if (ADD.equals(name)) {
            generateAddMethod(method);
        }
        else if (GET.equals(name)) {
            generateGetMethod(method);
        }
        else if (LIST.equals(name)) {
            generateListMethod(method);
        }
        else if (REMOVE.equals(name)) {
            generateRemoveMethod(method);
        }
        else if (UPDATE.equals(name)) {
            generateUpdateMethod(method);
        }
        else {
            generateActionMethod(method);
        }
    }

    private void generateAddMethod(Method method) {
        // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
        // rest of the methods are extracted explicitly by the implementation:
        Parameter mainParameter = method.getParameters().stream()
            .filter(x -> x.getType() instanceof StructType || x.getType() instanceof ListType)
            .findFirst()
            .orElse(null);
        if (mainParameter == null) {
            System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
            return;
        }

        // Calculate the Java type of the main parameter:
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);

        // Generate the imports:
        javaBuffer.addImport(Consumes.class);
        javaBuffer.addImport(POST.class);
        javaBuffer.addImport(Response.class);
        javaBuffer.addImports(mainTypeReference.getImports());

        // Generate the method:
        generateDoc(method);
        javaBuffer.addLine("@POST");
        javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());

        addResponseReturnMethod("add(%s %s)", mainTypeReference.getText(),
                javaNames.getJavaMemberStyleName(mainParameter.getName()));

        javaBuffer.addLine();
    }

    private void generateGetMethod(Method method) {
        // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
        // rest of the methods are extracted explicitly by the implementation:
        Parameter mainParameter = method.getParameters().stream()
            .filter(x -> x.getType() instanceof StructType)
            .findFirst()
            .orElse(null);
        if (mainParameter == null) {
            System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
            return;
        }

        // Most "Get" methods return the type that is declared in the model, but the root resource needs to return
        // "Response", because it has to be able to return the type declared in the model and also the XML schema and
        // the RSDL.
        Service service = method.getDeclaringService();
        boolean isRoot = service == service.getModel().getRoot();
        generateDoc(method);
        javaBuffer.addImport(GET.class);
        javaBuffer.addLine("@GET");
        if (isRoot)  {
            javaBuffer.addImport(Response.class);
            addResponseReturnMethod("get()");
        }
        else {
            Type mainType = mainParameter.getType();
            JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
            javaBuffer.addImports(mainTypeReference.getImports());
            addMethod(mainTypeReference.getText(), "get()");
        }

        javaBuffer.addLine();
    }

    private void generateListMethod(Method method) {
        // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
        // rest of the methods are extracted explicitly by the implementation:
        Parameter mainParameter = method.getParameters().stream()
            .filter(x -> x.getType() instanceof ListType)
            .findFirst()
            .orElse(null);
        if (mainParameter == null) {
            System.err.println("Method \"" + method + "\" doesn't have any list parameter");
            return;
        }

        // Calculate the Java type of the main parameter:
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);

        // Generate the imports:
        javaBuffer.addImport(GET.class);
        javaBuffer.addImports(mainTypeReference.getImports());

        // Generate the method:
        generateDoc(method);
        javaBuffer.addLine("@GET");
        addMethod(mainTypeReference.getText(), "list()");
        javaBuffer.addLine();
    }

    private void generateRemoveMethod(Method method) {
        // Generate the imports:
        javaBuffer.addImport(DELETE.class);
        javaBuffer.addImport(Response.class);

        // The remove methods that have structured parameters (currently only the method that removes a set of Gluster
        // bricks) need to receive an "Action" to carry those parameters.
        // TODO: Fix this renaming that method to "RemoveBricks" or something similar.
        boolean needsAction = method.parameters()
            .map(Parameter::getType)
            .anyMatch(x -> x instanceof StructType || x instanceof ListType);
        generateDoc(method);
        javaBuffer.addLine("@DELETE");
        if (needsAction) {
            javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
            addResponseReturnMethod("remove(Action action)");
        }
        else {
            addResponseReturnMethod("remove()");
        }

        javaBuffer.addLine();
    }

    private void generateUpdateMethod(Method method) {
        // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
        // rest of the methods are extracted explicitly by the implementation:
        Parameter mainParameter = method.getParameters().stream()
            .filter(x -> x.getType() instanceof StructType)
            .findFirst()
            .orElse(null);
        if (mainParameter == null) {
            System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
            return;
        }

        // Calculate the Java type of the main parameter:
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);

        // Generate the imports:
        javaBuffer.addImport(Consumes.class);
        javaBuffer.addImport(PUT.class);
        javaBuffer.addImports(mainTypeReference.getImports());

        // Generate the method:
        generateDoc(method);
        javaBuffer.addLine("@PUT");
        javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
        addMethod(mainTypeReference.getText(), "update(%s %s)",
                mainTypeReference.getText(),
                javaNames.getJavaMemberStyleName(mainParameter.getName()));

        javaBuffer.addLine();
    }

    private void generateActionMethod(Method method) {
        // Generate the imports:
        javaBuffer.addImport(Consumes.class);
        javaBuffer.addImport(POST.class);
        javaBuffer.addImport(Path.class);
        javaBuffer.addImport(Response.class);
        javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
        javaBuffer.addImport(javaPackages.getXjcPackageName(), "Actionable");

        // Generate the method:
        generateDoc(method);
        javaBuffer.addLine("@POST");
        javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
        javaBuffer.addLine("@Actionable");
        javaBuffer.addLine(
            "@Path(\"%s\")",
            jaxrsNames.getActionPath(method.getName())
        );
        addResponseReturnMethod(jaxrsNames.getMethodName(method.getName()) + "(Action action)");

        javaBuffer.addLine();
    }

    private void generateLocator(Locator locator) {
        if (locator.getParameters().isEmpty()) {
            generateParameterlessLocator(locator);
        }
        else {
            generateParameterizedLocator(locator);
        }
    }

    private void generateParameterizedLocator(Locator locator) {
        // Calculate the Java name of the service located by the given locator:
        JavaClassName interfaceName = jaxrsNames.getInterfaceName(locator.getService());

        // Generate the imports:
        javaBuffer.addImport(Path.class);
        javaBuffer.addImport(PathParam.class);
        javaBuffer.addImport(interfaceName);

        // Generate the locator method:
        generateDoc(locator);
        javaBuffer.addLine("@Path(\"{id}\")");
        javaBuffer.addLine(
            "%s get%sResource(@PathParam(\"id\") String id);",
            interfaceName.getSimpleName(),
            javaNames.getJavaClassStyleName(locator.getName())
        );

        javaBuffer.addLine();
    }

    private void generateParameterlessLocator(Locator locator) {
        // Calculate the Java name of the service located by the given locator:
        JavaClassName interfaceName = jaxrsNames.getInterfaceName(locator.getService());

        // Generate the imports:
        javaBuffer.addImport(Path.class);
        javaBuffer.addImport(PathParam.class);
        javaBuffer.addImport(interfaceName);

        // Generate the locator method:
        generateDoc(locator);
        javaBuffer.addLine(
            "@Path(\"%s\")",
            jaxrsNames.getActionPath(locator.getName())
        );
        javaBuffer.addLine(
            "%s get%sResource();",
            interfaceName.getSimpleName(),
            javaNames.getJavaClassStyleName(locator.getName())
        );

        javaBuffer.addLine();
    }

    private String generateMediaTypes() {
        return String.join(", ", MEDIA_TYPES);
    }
}

